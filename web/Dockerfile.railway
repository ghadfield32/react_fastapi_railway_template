# Railway Frontend Dockerfile
# =========================
# This Dockerfile implements an optimized build process with proper caching:
# - Uses explicit cache paths to avoid conflicts with Railway's build system
# - Implements multi-stage build for better layer caching
# - Separates dependency installation from build for better caching
# - Works from web directory context (Railway builds from web/)

# BUILD STAGE
FROM node:18-alpine AS build

# Set working directory
WORKDIR /app

# Debug: Show initial environment
RUN echo "ğŸ” INITIAL DEBUG: Node version:" && node --version
RUN echo "ğŸ” INITIAL DEBUG: NPM version:" && npm --version
RUN echo "ğŸ” INITIAL DEBUG: Working directory:" && pwd
RUN echo "ğŸ” INITIAL DEBUG: Available files:" && ls -la

# Copy package files first (for better layer caching)
# Since Railway builds from web/ context, we copy the local package files
COPY package.json package-lock.json ./

# Debug: Verify package files are copied
RUN echo "ğŸ” PACKAGE DEBUG: Package files after copy:" && ls -la package*
RUN echo "ğŸ” PACKAGE DEBUG: Package.json content:" && head -20 package.json
RUN echo "ğŸ” PACKAGE DEBUG: Package-lock.json exists:" && test -f package-lock.json && echo "YES" || echo "NO"

# Install dependencies
RUN echo "ğŸ” INSTALL DEBUG: Starting npm ci..." && \
    npm ci --prefer-offline --no-audit --loglevel=error && \
    echo "ğŸ” INSTALL DEBUG: npm ci completed successfully"

# Debug: Verify node_modules
RUN echo "ğŸ” INSTALL DEBUG: Node modules created:" && ls -la node_modules | head -10
RUN echo "ğŸ” INSTALL DEBUG: Key packages installed:" && \
    ls node_modules/ | grep -E "(react|vite|rollup)" || echo "Key packages not found"

# Copy source code
COPY . .

# Debug: Show what files are available after source copy
RUN echo "ğŸ” SOURCE DEBUG: All files after source copy:" && ls -la
RUN echo "ğŸ” SOURCE DEBUG: Source directory structure:" && find . -type f -name "*.ts*" -o -name "*.js*" | head -20

# Build with environment variables
# Railway provides these at build time, but we need to make sure they're available
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL

# Debug: Show what environment variables are available during build
RUN echo "ğŸ” ENV DEBUG: VITE_API_URL = $VITE_API_URL"
RUN echo "ğŸ” ENV DEBUG: All ENV vars:" && env | grep -E "(VITE_|NODE_|RAILWAY_)" || true

# Build the application with verbose output
RUN echo "ğŸ” BUILD DEBUG: Starting build process..." && \
    npm run build 2>&1 | tee build.log && \
    echo "ğŸ” BUILD DEBUG: Build completed successfully"

# Debug: Verify build output
RUN echo "ğŸ” BUILD DEBUG: Build output directory:" && ls -la dist/
RUN echo "ğŸ” BUILD DEBUG: Built assets:" && find dist/ -type f | head -10

# Debug: Check if the build contains the correct API URL
RUN echo "ğŸ” BUILD DEBUG: Checking built files for API URL..." && \
    find dist -name "*.js" -exec grep -l "fastapi-production-1d13.up.railway.app" {} \; || \
    echo "ğŸ” BUILD DEBUG: API URL not found in built files"

# Debug: Show actual content of built files (first 50 lines)
RUN echo "ğŸ” BUILD DEBUG: Sample content from built JS files:" && \
    find dist -name "*.js" | head -1 | xargs head -50 || \
    echo "ğŸ” BUILD DEBUG: No JS files found"

# Debug: Search for any occurrence of 'VITE_API_URL' in built files
RUN echo "ğŸ” BUILD DEBUG: Searching for VITE_API_URL in built files:" && \
    find dist -name "*.js" -exec grep -H "VITE_API_URL" {} \; || \
    echo "ğŸ” BUILD DEBUG: VITE_API_URL not found in built files"

# SERVE STAGE
FROM node:18-alpine

WORKDIR /app

# Debug: Show serve stage environment
RUN echo "ğŸ” SERVE DEBUG: Node version in serve stage:" && node --version

# Install serve globally
RUN npm install -g serve

# Copy only the built assets from build stage
COPY --from=build /app/dist ./dist

# Debug: Verify dist files are copied
RUN echo "ğŸ” SERVE DEBUG: Dist files copied:" && ls -la dist/
RUN echo "ğŸ” SERVE DEBUG: Total files in dist:" && find dist/ -type f | wc -l

# Expose port
EXPOSE $PORT

# Debug: Show final environment before starting
RUN echo "ğŸ” SERVE DEBUG: Final environment:" && env | grep -E "(PORT|NODE_)" || true

# Start the application
CMD ["sh", "-c", "echo 'ğŸ” SERVE DEBUG: Starting server on port $PORT' && serve -s dist -l $PORT --no-clipboard --no-port-switching"] 
